{"js/build_runtime.sh":"#!/bin/sh\n\n# Assembles the es6_runtime.js file from the inputs.\n\nhelp() {\n  cat <<EOF >&2\nUsage: build_runtime.sh [OPTIONS]\nOptions:\n  --compiler=PATH/TO.JAR\n  --js_output_file=FILENAME\nEOF\n  exit $1\n}\n\ndir=\"$(dirname $0)\"\ncompiler=\"$dir/../../../../../../build/compiler.jar\"\noutput=/dev/stdout\n\nwhile [ $# -gt 0 ]; do\n  arg=$1\n  shift\n  case \"$arg\" in\n    (--*=*) set -- \"${arg#*=}\" \"$@\"; arg=${arg%%=*} ;;\n  esac\n  case \"$arg\" in\n    (--help) help 0 ;;\n    (--compiler) compiler=$1; shift ;;\n    (--js_output_file) output=$1; shift ;;\n    (*) echo \"Unknown option: $arg\" >&2; help 1 ;;\n  esac\ndone\n\n{\n  cat license.js\n  echo -e '\\n// GENERATED FILE. DO NOT EDIT. REBUILD WITH build_runtime.sh.\\n'\n  java -jar $compiler \"${args[@]}\" \\\n       --formatting=PRETTY_PRINT \\\n       --noinject_libraries \\\n       --compilation_level=WHITESPACE_ONLY \\\n       --preserve_type_annotations \\\n       --language_in=ES6_STRICT \\\n       --language_out=ES5_STRICT \\\n       --js=\"$dir/es6/runtime.js\" \\\n       --js=\"$dir/es6/object.js\" \\\n      | sed 's/ *$//g'\n  echo\n} >| $output\n","js/base.js":"/*\n * Copyright 2012 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * @fileoverview The base namespace for code injected by the compiler\n * at compile-time.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\n\n/** @const */\nvar $jscomp = {};\n\n/** @const Locals for goog.scope */\n$jscomp.scope = {};\n","js/es6_dart_runtime.js":"/*\n * Copyright 2014 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview  Additional runtime functions required for transpilation from\n * ES6 to ES5 of code generated by the Dart Dev Compiler.\n *\n * Note that DDC's output cannot currently be lowered to ES3 (heavy use of\n * getters or setters, including in the runtime), so these helpers make no\n * attempt of fallback behaviour when methods like Object.getPrototypeOf or\n * Object.getOwnPropertyDescriptor are undefined (unlike helpers in\n * es6_runtime.js).\n *\n * @author ochafik@google.com (Olivier Chafik)\n */\n'require es6_runtime';\n\n/**\n * Gets a property descriptor for a target instance, skipping its class\n * and walking up the super-classes hierarchy.\n *\n * @private\n * @param {!Object} target\n * @param {!string} name\n * @return {!Object.<ObjectPropertyDescriptor>|undefined}\n */\n$jscomp.getSuperPropertyDescriptor_ = function(target, name) {\n  var getPrototypeOf = $jscomp.global.Object.getPrototypeOf;\n  var getOwnPropertyDescriptor = $jscomp.global.Object.getOwnPropertyDescriptor;\n  var cls = getPrototypeOf(target);\n  while (cls != null) {\n    cls = getPrototypeOf(cls);\n    if (cls != null) {\n      var desc = getOwnPropertyDescriptor(cls, name);\n      if (desc != null) {\n        return desc;\n      }\n    }\n  }\n  return undefined;\n};\n\n/**\n * Gets a property of a target instance using its super class getter or value,\n * or returns undefined if that property is not defined on any ancestor.\n *\n * @param {!Object} target\n * @param {!string} propertyName\n * @return {*}\n */\n$jscomp.superGet = function(target, propertyName) {\n  var desc = $jscomp.getSuperPropertyDescriptor_(target, propertyName);\n  return desc && (desc.get ? desc.get.call(target) : desc.value);\n};\n\n/**\n * Sets a property on a target instance using its super setter if is defined\n * on any ancestor, or setting it as a simple property on the target otherwise.\n *\n * @template T\n * @param {!Object} target\n * @param {!string} propertyName\n * @param {T} value\n * @return {T}\n */\n$jscomp.superSet = function(target, propertyName, value) {\n  var desc = $jscomp.getSuperPropertyDescriptor_(target, propertyName);\n  if (desc) {\n    if (!desc.set) {\n      throw new TypeError('No setter for super.' + propertyName);\n    }\n    desc.set.call(target, value);\n  } else {\n    target[propertyName] = value;\n  }\n  return value;\n};\n","js/es6_runtime.js":"/*\n * Copyright 2015 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// GENERATED FILE. DO NOT EDIT. REBUILD WITH build_runtime.sh.\n\n'use strict';\"require base\";\n\"declare window global\";\n/**\n @param {!Object} maybeGlobal\n @return {!Object}\n @suppress {undefinedVars}\n */\n$jscomp.getGlobal = function(maybeGlobal) {\n  return typeof window != \"undefined\" && window === maybeGlobal ? maybeGlobal : typeof global != \"undefined\" ? global : maybeGlobal;\n};\n/** @const @type {!Object} */ $jscomp.global = $jscomp.getGlobal(this);\n/**\n @suppress {reportUnknownTypes}\n */\n$jscomp.initSymbol = function() {\n  if (!$jscomp.global.Symbol) {\n    $jscomp.global.Symbol = $jscomp.Symbol;\n  }\n  $jscomp.initSymbol = function() {\n  };\n};\n/** @private @type {number} */ $jscomp.symbolCounter_ = 0;\n/**\n @param {string} description\n @return {symbol}\n @suppress {reportUnknownTypes}\n */\n$jscomp.Symbol = function(description) {\n  return /** @type {symbol} */ (\"jscomp_symbol_\" + description + $jscomp.symbolCounter_++);\n};\n/**\n @suppress {reportUnknownTypes}\n */\n$jscomp.initSymbolIterator = function() {\n  $jscomp.initSymbol();\n  if (!$jscomp.global.Symbol.iterator) {\n    $jscomp.global.Symbol.iterator = $jscomp.global.Symbol(\"iterator\");\n  }\n  $jscomp.initSymbolIterator = function() {\n  };\n};\n/**\n @param {(string|!Array<T>|!Iterable<T>|!Iterator<T>|!Arguments<T>)} iterable\n @return {!Iterator<T>}\n @template T\n @suppress {reportUnknownTypes}\n */\n$jscomp.makeIterator = function(iterable) {\n  $jscomp.initSymbolIterator();\n  if (iterable[$jscomp.global.Symbol.iterator]) {\n    return iterable[$jscomp.global.Symbol.iterator]();\n  }\n  var index = 0;\n  return /** @type {!Iterator} */ ({next:function() {\n    if (index == iterable.length) {\n      return {done:true};\n    } else {\n      return {done:false, value:iterable[index++]};\n    }\n  }});\n};\n/**\n @param {!Iterator<T>} iterator\n @return {!Array<T>}\n @template T\n */\n$jscomp.arrayFromIterator = function(iterator) {\n  var i;\n  /** @const */ var arr = [];\n  while (!(i = iterator.next()).done) {\n    arr.push(i.value);\n  }\n  return arr;\n};\n/**\n @param {(string|!Array<T>|!Iterable<T>|!Arguments<T>)} iterable\n @return {!Array<T>}\n @template T\n */\n$jscomp.arrayFromIterable = function(iterable) {\n  if (iterable instanceof Array) {\n    return iterable;\n  } else {\n    return $jscomp.arrayFromIterator($jscomp.makeIterator(iterable));\n  }\n};\n/**\n @param {!Function} childCtor\n @param {!Function} parentCtor\n */\n$jscomp.inherits = function(childCtor, parentCtor) {\n  /** @constructor */ function tempCtor() {\n  }\n  tempCtor.prototype = parentCtor.prototype;\n  childCtor.prototype = new tempCtor;\n  /** @override */ childCtor.prototype.constructor = childCtor;\n  for (var p in parentCtor) {\n    if ($jscomp.global.Object.defineProperties) {\n      var descriptor = $jscomp.global.Object.getOwnPropertyDescriptor(parentCtor, p);\n      if (descriptor) {\n        $jscomp.global.Object.defineProperty(childCtor, p, descriptor);\n      }\n    } else {\n      childCtor[p] = parentCtor[p];\n    }\n  }\n};\n$jscomp.array = $jscomp.array || {};\n/**\n @private\n @return {{done:boolean}}\n */\n$jscomp.array.done_ = function() {\n  return {done:true, value:void 0};\n};\n/**\n @private\n @param {!IArrayLike<INPUT>} array\n @param {function(number,INPUT):OUTPUT} func\n @return {!IteratorIterable<OUTPUT>}\n @template INPUT,OUTPUT\n @suppress {checkTypes}\n */\n$jscomp.array.arrayIterator_ = function(array, func) {\n  if (array instanceof String) {\n    array = String(array);\n  }\n  var i = 0;\n  $jscomp.initSymbol();\n  $jscomp.initSymbolIterator();\n  var $jscomp$compprop0 = {};\n  /** @const */ var iter = ($jscomp$compprop0.next = function() {\n    if (i < array.length) {\n      /** @const */ var index = i++;\n      return {value:func(index, array[index]), done:false};\n    }\n    iter.next = $jscomp.array.done_;\n    return $jscomp.array.done_();\n  }, $jscomp$compprop0[Symbol.iterator] = function() {\n    return iter;\n  }, $jscomp$compprop0);\n  return iter;\n};\n/**\n @private\n @param {!IArrayLike<VALUE>} array\n @param {function(this:THIS,VALUE,number,!IArrayLike<VALUE>):*} callback\n @param {THIS} thisArg\n @return {{i:number,v:(VALUE|undefined)}}\n @template THIS,VALUE\n */\n$jscomp.array.findInternal_ = function(array, callback, thisArg) {\n  if (array instanceof String) {\n    array = /** @type {!IArrayLike} */ (String(array));\n  }\n  /** @const */ var len = array.length;\n  for (var i = 0;i < len;i++) {\n    /** @const */ var value = array[i];\n    if (callback.call(thisArg, value, i, array)) {\n      return {i:i, v:value};\n    }\n  }\n  return {i:-1, v:void 0};\n};\n/**\n @param {(!IArrayLike<INPUT>|!Iterator<INPUT>|!Iterable<INPUT>)} arrayLike\n @param {function(this:THIS,INPUT):OUTPUT=} opt_mapFn\n @param {THIS=} opt_thisArg\n @return {!Array<OUTPUT>}\n @template INPUT,OUTPUT,THIS\n */\n$jscomp.array.from = function(arrayLike, opt_mapFn, opt_thisArg) {\n  opt_mapFn = opt_mapFn === undefined ? function(x) {\n    return x;\n  } : opt_mapFn;\n  /** @const */ var result = [];\n  $jscomp.initSymbol();\n  $jscomp.initSymbolIterator();\n  if (arrayLike[Symbol.iterator]) {\n    $jscomp.initSymbol();\n    $jscomp.initSymbolIterator();\n    /** @const */ var iter = arrayLike[Symbol.iterator]();\n    var next;\n    while (!(next = iter.next()).done) {\n      result.push(opt_mapFn.call(opt_thisArg, next.value));\n    }\n  } else {\n    /** @const */ var len = arrayLike.length;\n    for (var i = 0;i < len;i++) {\n      result.push(opt_mapFn.call(opt_thisArg, arrayLike[i]));\n    }\n  }\n  return result;\n};\n/**\n @param {...*} elements\n @return {!Array<*>}\n */\n$jscomp.array.of = function(elements) {\n  var $jscomp$restParams = [];\n  for (var $jscomp$restIndex = 0;$jscomp$restIndex < arguments.length;++$jscomp$restIndex) {\n    $jscomp$restParams[$jscomp$restIndex - 0] = arguments[$jscomp$restIndex];\n  }\n  var /** @type {!Array<*>} */ elements$10 = $jscomp$restParams;\n  return $jscomp.array.from(elements$10);\n};\n/**\n @this {!IArrayLike<VALUE>}\n @return {!IteratorIterable<!Array<(number|VALUE)>>}\n @template VALUE\n */\n$jscomp.array.entries = function() {\n  return $jscomp.array.arrayIterator_(this, function(i, v) {\n    return [i, v];\n  });\n};\n/**\n @private\n @param {string} method\n @param {!Function} fn\n */\n$jscomp.array.installHelper_ = function(method, fn) {\n  if (!Array.prototype[method] && Object.defineProperties && Object.defineProperty) {\n    Object.defineProperty(Array.prototype, method, {configurable:true, enumerable:false, writable:true, value:fn});\n  }\n};\n/**\n @suppress {checkTypes,const}\n */\n$jscomp.array.entries$install = function() {\n  $jscomp.array.installHelper_(\"entries\", $jscomp.array.entries);\n};\n/**\n @this {!IArrayLike}\n @return {!IteratorIterable<number>}\n */\n$jscomp.array.keys = function() {\n  return $jscomp.array.arrayIterator_(this, function(i) {\n    return i;\n  });\n};\n/**\n @suppress {checkTypes,const}\n */\n$jscomp.array.keys$install = function() {\n  $jscomp.array.installHelper_(\"keys\", $jscomp.array.keys);\n};\n/**\n @this {!IArrayLike<VALUE>}\n @return {!IteratorIterable<VALUE>}\n @template VALUE\n */\n$jscomp.array.values = function() {\n  return $jscomp.array.arrayIterator_(this, function(_, v) {\n    return v;\n  });\n};\n/**\n @suppress {checkTypes,const}\n */\n$jscomp.array.values$install = function() {\n  $jscomp.array.installHelper_(\"values\", $jscomp.array.values);\n};\n/**\n @this {!IArrayLike<VALUE>}\n @param {number} target\n @param {number} start\n @param {number=} opt_end\n @return {!IArrayLike<VALUE>}\n @template VALUE\n */\n$jscomp.array.copyWithin = function(target, start, opt_end) {\n  /** @const */ var len = this.length;\n  target = Number(target);\n  start = Number(start);\n  opt_end = Number(opt_end != null ? opt_end : len);\n  if (target < start) {\n    opt_end = Math.min(opt_end, len);\n    while (start < opt_end) {\n      if (start in this) {\n        this[target++] = this[start++];\n      } else {\n        delete this[target++];\n        start++;\n      }\n    }\n  } else {\n    opt_end = Math.min(opt_end, len + start - target);\n    target += opt_end - start;\n    while (opt_end > start) {\n      if (--opt_end in this) {\n        this[--target] = this[opt_end];\n      } else {\n        delete this[target];\n      }\n    }\n  }\n  return this;\n};\n/**\n @suppress {checkTypes,const}\n */\n$jscomp.array.copyWithin$install = function() {\n  $jscomp.array.installHelper_(\"copyWithin\", $jscomp.array.copyWithin);\n};\n/**\n @this {!IArrayLike<VALUE>}\n @param {VALUE} value\n @param {number=} opt_start\n @param {number=} opt_end\n @return {!IArrayLike<VALUE>}\n @template VALUE\n */\n$jscomp.array.fill = function(value, opt_start, opt_end) {\n  opt_start = opt_start === undefined ? 0 : opt_start;\n  if (opt_end == null || !value.length) {\n    opt_end = this.length || 0;\n  }\n  opt_end = Number(opt_end);\n  for (var i = Number(opt_start || 0);i < opt_end;i++) {\n    this[i] = value;\n  }\n  return this;\n};\n/**\n @suppress {checkTypes,const}\n */\n$jscomp.array.fill$install = function() {\n  $jscomp.array.installHelper_(\"fill\", $jscomp.array.fill);\n};\n/**\n @this {!IArrayLike<VALUE>}\n @param {function(this:THIS,VALUE,number,!IArrayLike<VALUE>):*} callback\n @param {THIS=} opt_thisArg\n @return {(VALUE|undefined)}\n @template VALUE,THIS\n */\n$jscomp.array.find = function(callback, opt_thisArg) {\n  return $jscomp.array.findInternal_(this, callback, opt_thisArg).v;\n};\n/**\n @suppress {checkTypes,const}\n */\n$jscomp.array.find$install = function() {\n  $jscomp.array.installHelper_(\"find\", $jscomp.array.find);\n};\n/**\n @this {!IArrayLike<VALUE>}\n @param {function(this:THIS,VALUE,number,!IArrayLike<VALUE>):*} callback\n @param {THIS=} opt_thisArg\n @return {(VALUE|undefined)}\n @template VALUE,THIS\n */\n$jscomp.array.findIndex = function(callback, opt_thisArg) {\n  return $jscomp.array.findInternal_(this, callback, opt_thisArg).i;\n};\n/**\n @suppress {checkTypes,const}\n */\n$jscomp.array.findIndex$install = function() {\n  $jscomp.array.installHelper_(\"findIndex\", $jscomp.array.findIndex);\n};\n/**\n @struct\n @constructor\n @implements {Iterable<!Array<(KEY|VALUE)>>}\n @param {(!Iterable<!Array<(KEY|VALUE)>>|!Array<!Array<(KEY|VALUE)>>)=} opt_iterable\n @template KEY,VALUE\n */\n$jscomp.Map = function(opt_iterable) {\n  opt_iterable = opt_iterable === undefined ? [] : opt_iterable;\n  /** @private @type {!Object<!Array<!$jscomp.Map.Entry_<KEY,VALUE>>>} */ this.data_ = {};\n  /** @private @type {!$jscomp.Map.Entry_<KEY,VALUE>} */ this.head_ = $jscomp.Map.createHead_();\n  /** @type {number} */ this.size = 0;\n  if (opt_iterable) {\n    for (var $jscomp$iter$1 = $jscomp.makeIterator(opt_iterable), $jscomp$key$item = $jscomp$iter$1.next();!$jscomp$key$item.done;$jscomp$key$item = $jscomp$iter$1.next()) {\n      /** @const */ var item = $jscomp$key$item.value;\n      this.set(/** @type {KEY} */ (item[0]), /** @type {VALUE} */ (item[1]));\n    }\n  }\n};\n/**\n @private\n @return {boolean}\n */\n$jscomp.Map.checkBrowserConformance_ = function() {\n  /** @const @type {function(new:Map,!Iterator)} */ var Map = $jscomp.global[\"Map\"];\n  if (!Map || !Map.prototype.entries || !Object.seal) {\n    return false;\n  }\n  try {\n    /** @const */ var key = Object.seal({x:4});\n    /** @const */ var map = new Map($jscomp.makeIterator([[key, \"s\"]]));\n    if (map.get(key) != \"s\" || map.size != 1 || map.get({x:4}) || map.set({x:4}, \"t\") != map || map.size != 2) {\n      return false;\n    }\n    /** @const @type {!Iterator<!Array>} */ var iter = map.entries();\n    var item = iter.next();\n    if (item.done || item.value[0] != key || item.value[1] != \"s\") {\n      return false;\n    }\n    item = iter.next();\n    if (item.done || item.value[0].x != 4 || item.value[1] != \"t\" || !iter.next().done) {\n      return false;\n    }\n    return true;\n  } catch (err) {\n    return false;\n  }\n};\n/**\n @private\n @return {!$jscomp.Map.Entry_<KEY,VALUE>}\n @template KEY,VALUE\n @suppress {checkTypes}\n */\n$jscomp.Map.createHead_ = function() {\n  /** @const */ var head = {};\n  head.previous = head.next = head.head = head;\n  return head;\n};\n/**\n @private\n @param {*} obj\n @return {string}\n */\n$jscomp.Map.getId_ = function(obj) {\n  if (!(obj instanceof Object)) {\n    return String(obj);\n  }\n  if (!($jscomp.Map.key_ in obj)) {\n    if (obj instanceof Object && Object.isExtensible && Object.isExtensible(obj)) {\n      $jscomp.Map.defineProperty_(obj, $jscomp.Map.key_, ++$jscomp.Map.index_);\n    }\n  }\n  if (!($jscomp.Map.key_ in obj)) {\n    return \" \" + obj;\n  }\n  return obj[$jscomp.Map.key_];\n};\n/**\n @param {KEY} key\n @param {VALUE} value\n */\n$jscomp.Map.prototype.set = function(key, value) {\n  var $jscomp$destructuring$var0 = this.maybeGetEntry_(key);\n  var id = $jscomp$destructuring$var0.id;\n  var list = $jscomp$destructuring$var0.list;\n  var entry = $jscomp$destructuring$var0.entry;\n  if (!list) {\n    list = this.data_[id] = [];\n  }\n  if (!entry) {\n    entry = {next:this.head_, previous:this.head_.previous, head:this.head_, key:key, value:value};\n    list.push(entry);\n    this.head_.previous.next = entry;\n    this.head_.previous = entry;\n    this.size++;\n  } else {\n    entry.value = value;\n  }\n  return this;\n};\n/**\n @param {KEY} key\n @return {boolean}\n */\n$jscomp.Map.prototype.delete = function(key) {\n  /** @const */ var $jscomp$destructuring$var1 = this.maybeGetEntry_(key);\n  /** @const */ var id = $jscomp$destructuring$var1.id;\n  /** @const */ var list = $jscomp$destructuring$var1.list;\n  /** @const */ var index = $jscomp$destructuring$var1.index;\n  /** @const */ var entry = $jscomp$destructuring$var1.entry;\n  if (entry && list) {\n    list.splice(index, 1);\n    if (!list.length) {\n      delete this.data_[id];\n    }\n    entry.previous.next = entry.next;\n    entry.next.previous = entry.previous;\n    entry.head = null;\n    this.size--;\n    return true;\n  }\n  return false;\n};\n$jscomp.Map.prototype.clear = function() {\n  this.data_ = {};\n  this.head_ = this.head_.previous = $jscomp.Map.createHead_();\n  this.size = 0;\n};\n/**\n @param {*} key\n @return {boolean}\n */\n$jscomp.Map.prototype.has = function(key) {\n  return Boolean(this.maybeGetEntry_(key).entry);\n};\n/**\n @param {*} key\n @return {(VALUE|undefined)}\n */\n$jscomp.Map.prototype.get = function(key) {\n  /** @const */ var $jscomp$destructuring$var2 = this.maybeGetEntry_(key);\n  /** @const */ var entry = $jscomp$destructuring$var2.entry;\n  return entry && entry.value;\n};\n/**\n @private\n @param {KEY} key\n @return {{id:string,list:(!Array<!$jscomp.Map.Entry_<KEY,VALUE>>|undefined),index:number,entry:(!$jscomp.Map.Entry_<KEY,VALUE>|undefined)}}\n */\n$jscomp.Map.prototype.maybeGetEntry_ = function(key) {\n  /** @const */ var id = $jscomp.Map.getId_(key);\n  /** @const */ var list = this.data_[id];\n  if (list) {\n    for (var index = 0;index < list.length;index++) {\n      /** @const */ var entry = list[index];\n      if (key !== key && entry.key !== entry.key || key === entry.key) {\n        return {id:id, list:list, index:index, entry:entry};\n      }\n    }\n  }\n  return {id:id, list:list, index:-1, entry:void 0};\n};\n/**\n @return {!IteratorIterable<!Array<(KEY|VALUE)>>}\n */\n$jscomp.Map.prototype.entries = function() {\n  return this.iter_(function(entry) {\n    return [entry.key, entry.value];\n  });\n};\n/**\n @return {!IteratorIterable<KEY>}\n */\n$jscomp.Map.prototype.keys = function() {\n  return this.iter_(function(entry) {\n    return entry.key;\n  });\n};\n/**\n @return {!IteratorIterable<VALUE>}\n */\n$jscomp.Map.prototype.values = function() {\n  return this.iter_(function(entry) {\n    return entry.value;\n  });\n};\n/**\n @param {function(this:THIS,VALUE,KEY,!$jscomp.Map<KEY,VALUE>)} callback\n @param {THIS=} opt_thisArg\n @template THIS\n */\n$jscomp.Map.prototype.forEach = function(callback, opt_thisArg) {\n  for (var $jscomp$iter$2 = $jscomp.makeIterator(this.entries()), $jscomp$key$entry = $jscomp$iter$2.next();!$jscomp$key$entry.done;$jscomp$key$entry = $jscomp$iter$2.next()) {\n    /** @const */ var entry = $jscomp$key$entry.value;\n    callback.call(opt_thisArg, /** @type {VALUE} */ (entry[1]), /** @type {KEY} */ (entry[0]), /** @type {!$jscomp.Map<KEY,VALUE>} */ (this));\n  }\n};\n/**\n @private\n @param {function(!$jscomp.Map.Entry_<KEY,VALUE>):T} func\n @return {!IteratorIterable<T>}\n @template T\n */\n$jscomp.Map.prototype.iter_ = function(func) {\n  /** @const */ var map = this;\n  var entry = this.head_;\n  $jscomp.initSymbol();\n  $jscomp.initSymbolIterator();\n  var $jscomp$compprop3 = {};\n  return /** @type {!IteratorIterable} */ ($jscomp$compprop3.next = function() {\n    if (entry) {\n      while (entry.head != map.head_) {\n        entry = entry.previous;\n      }\n      while (entry.next != entry.head) {\n        entry = entry.next;\n        return {done:false, value:func(entry)};\n      }\n      entry = null;\n    }\n    return {done:true, value:void 0};\n  }, $jscomp$compprop3[Symbol.iterator] = function() {\n    return /** @type {!Iterator} */ (this);\n  }, $jscomp$compprop3);\n};\n/** @private @type {number} */ $jscomp.Map.index_ = 0;\n/**\n @private\n @param {!Object} obj\n @param {string} key\n @param {*} value\n */\n$jscomp.Map.defineProperty_ = Object.defineProperty ? function(obj, key, value) {\n  Object.defineProperty(obj, key, {value:String(value)});\n} : function(obj, key, value) {\n  obj[key] = String(value);\n};\n/**\n @private\n @record\n @template KEY,VALUE\n */\n$jscomp.Map.Entry_ = function() {\n};\n/** @type {!$jscomp.Map.Entry_<KEY,VALUE>} */ $jscomp.Map.Entry_.prototype.previous;\n/** @type {!$jscomp.Map.Entry_<KEY,VALUE>} */ $jscomp.Map.Entry_.prototype.next;\n/** @type {?Object} */ $jscomp.Map.Entry_.prototype.head;\n/** @type {KEY} */ $jscomp.Map.Entry_.prototype.key;\n/** @type {VALUE} */ $jscomp.Map.Entry_.prototype.value;\n/** @define {boolean} */ $jscomp.Map.ASSUME_NO_NATIVE = false;\n$jscomp.Map$install = function() {\n  $jscomp.initSymbol();\n  $jscomp.initSymbolIterator();\n  if (!$jscomp.Map.ASSUME_NO_NATIVE && $jscomp.Map.checkBrowserConformance_()) {\n    $jscomp.Map = $jscomp.global[\"Map\"];\n  } else {\n    $jscomp.initSymbol();\n    $jscomp.initSymbolIterator();\n    $jscomp.Map.prototype[Symbol.iterator] = $jscomp.Map.prototype.entries;\n    $jscomp.initSymbol();\n    /** @private @const @type {symbol} */ $jscomp.Map.key_ = Symbol(\"map-id-key\");\n  }\n  $jscomp.Map$install = function() {\n  };\n};\n$jscomp.math = $jscomp.math || {};\n/**\n @param {*} x\n @return {number}\n */\n$jscomp.math.clz32 = function(x) {\n  x = Number(x) >>> 0;\n  if (x === 0) {\n    return 32;\n  }\n  var result = 0;\n  if ((x & 4294901760) === 0) {\n    x <<= 16;\n    result += 16;\n  }\n  if ((x & 4278190080) === 0) {\n    x <<= 8;\n    result += 8;\n  }\n  if ((x & 4026531840) === 0) {\n    x <<= 4;\n    result += 4;\n  }\n  if ((x & 3221225472) === 0) {\n    x <<= 2;\n    result += 2;\n  }\n  if ((x & 2147483648) === 0) {\n    result++;\n  }\n  return result;\n};\n/**\n @param {*} a\n @param {*} b\n @return {number}\n */\n$jscomp.math.imul = function(a, b) {\n  a = Number(a);\n  b = Number(b);\n  /** @const */ var ah = a >>> 16 & 65535;\n  /** @const */ var al = a & 65535;\n  /** @const */ var bh = b >>> 16 & 65535;\n  /** @const */ var bl = b & 65535;\n  /** @const */ var lh = ah * bl + al * bh << 16 >>> 0;\n  return al * bl + lh | 0;\n};\n/**\n @param {*} x\n @return {number}\n */\n$jscomp.math.sign = function(x) {\n  x = Number(x);\n  return x === 0 || isNaN(x) ? x : x > 0 ? 1 : -1;\n};\n/**\n @param {*} x\n @return {number}\n */\n$jscomp.math.log10 = function(x) {\n  return Math.log(x) / Math.LN10;\n};\n/**\n @param {*} x\n @return {number}\n */\n$jscomp.math.log2 = function(x) {\n  return Math.log(x) / Math.LN2;\n};\n/**\n @param {*} x\n @return {number}\n */\n$jscomp.math.log1p = function(x) {\n  x = Number(x);\n  if (x < .25 && x > -.25) {\n    var y = x;\n    var d = 1;\n    var z = x;\n    var zPrev = 0;\n    var s = 1;\n    while (zPrev != z) {\n      y *= x;\n      s *= -1;\n      z = (zPrev = z) + s * y / ++d;\n    }\n    return z;\n  }\n  return Math.log(1 + x);\n};\n/**\n @param {*} x\n @return {number}\n */\n$jscomp.math.expm1 = function(x) {\n  x = Number(x);\n  if (x < .25 && x > -.25) {\n    var y = x;\n    var d = 1;\n    var z = x;\n    var zPrev = 0;\n    while (zPrev != z) {\n      y *= x / ++d;\n      z = (zPrev = z) + y;\n    }\n    return z;\n  }\n  return Math.exp(x) - 1;\n};\n/**\n @param {*} x\n @return {number}\n */\n$jscomp.math.cosh = function(x) {\n  x = Number(x);\n  return (Math.exp(x) + Math.exp(-x)) / 2;\n};\n/**\n @param {*} x\n @return {number}\n */\n$jscomp.math.sinh = function(x) {\n  x = Number(x);\n  if (x === 0) {\n    return x;\n  }\n  return (Math.exp(x) - Math.exp(-x)) / 2;\n};\n/**\n @param {*} x\n @return {number}\n */\n$jscomp.math.tanh = function(x) {\n  x = Number(x);\n  if (x === 0) {\n    return x;\n  }\n  /** @const */ var y = Math.exp(2 * -Math.abs(x));\n  /** @const */ var z = (1 - y) / (1 + y);\n  return x < 0 ? -z : z;\n};\n/**\n @param {*} x\n @return {number}\n */\n$jscomp.math.acosh = function(x) {\n  x = Number(x);\n  return Math.log(x + Math.sqrt(x * x - 1));\n};\n/**\n @param {*} x\n @return {number}\n */\n$jscomp.math.asinh = function(x) {\n  x = Number(x);\n  if (x === 0) {\n    return x;\n  }\n  /** @const */ var y = Math.log(Math.abs(x) + Math.sqrt(x * x + 1));\n  return x < 0 ? -y : y;\n};\n/**\n @param {*} x\n @return {number}\n */\n$jscomp.math.atanh = function(x) {\n  x = Number(x);\n  return ($jscomp.math.log1p(x) - $jscomp.math.log1p(-x)) / 2;\n};\n/**\n @param {*} x\n @param {*} y\n @param {...*} rest\n @return {number}\n */\n$jscomp.math.hypot = function(x, y, rest) {\n  var $jscomp$restParams = [];\n  for (var $jscomp$restIndex = 2;$jscomp$restIndex < arguments.length;++$jscomp$restIndex) {\n    $jscomp$restParams[$jscomp$restIndex - 2] = arguments[$jscomp$restIndex];\n  }\n  var /** @type {!Array<*>} */ rest$11 = $jscomp$restParams;\n  x = Number(x);\n  y = Number(y);\n  var max = Math.max(Math.abs(x), Math.abs(y));\n  for (var $jscomp$iter$4 = $jscomp.makeIterator(rest$11), $jscomp$key$z = $jscomp$iter$4.next();!$jscomp$key$z.done;$jscomp$key$z = $jscomp$iter$4.next()) {\n    var z = $jscomp$key$z.value;\n    max = Math.max(max, Math.abs(z));\n  }\n  if (max > 1E100 || max < 1E-100) {\n    x = x / max;\n    y = y / max;\n    var sum = x * x + y * y;\n    for (var $jscomp$iter$5 = $jscomp.makeIterator(rest$11), $jscomp$key$z = $jscomp$iter$5.next();!$jscomp$key$z.done;$jscomp$key$z = $jscomp$iter$5.next()) {\n      var z$12 = $jscomp$key$z.value;\n      z$12 = Number(z$12) / max;\n      sum += z$12 * z$12;\n    }\n    return Math.sqrt(sum) * max;\n  } else {\n    var sum$13 = x * x + y * y;\n    for (var $jscomp$iter$6 = $jscomp.makeIterator(rest$11), $jscomp$key$z = $jscomp$iter$6.next();!$jscomp$key$z.done;$jscomp$key$z = $jscomp$iter$6.next()) {\n      var z$14 = $jscomp$key$z.value;\n      z$14 = Number(z$14);\n      sum$13 += z$14 * z$14;\n    }\n    return Math.sqrt(sum$13);\n  }\n};\n/**\n @param {*} x\n @return {number}\n */\n$jscomp.math.trunc = function(x) {\n  x = Number(x);\n  if (isNaN(x) || x === Infinity || x === -Infinity || x === 0) {\n    return x;\n  }\n  /** @const */ var y = Math.floor(Math.abs(x));\n  return x < 0 ? -y : y;\n};\n/**\n @param {*} x\n @return {number}\n */\n$jscomp.math.cbrt = function(x) {\n  if (x === 0) {\n    return x;\n  }\n  x = Number(x);\n  /** @const */ var y = Math.pow(Math.abs(x), 1 / 3);\n  return x < 0 ? -y : y;\n};\n$jscomp.number = $jscomp.number || {};\n/**\n @param {*} x\n @return {boolean}\n */\n$jscomp.number.isFinite = function(x) {\n  if (typeof x !== \"number\") {\n    return false;\n  }\n  return !isNaN(x) && x !== Infinity && x !== -Infinity;\n};\n/**\n @param {*} x\n @return {boolean}\n */\n$jscomp.number.isInteger = function(x) {\n  if (!$jscomp.number.isFinite(x)) {\n    return false;\n  }\n  return x === Math.floor(x);\n};\n/**\n @param {*} x\n @return {boolean}\n */\n$jscomp.number.isNaN = function(x) {\n  return typeof x === \"number\" && isNaN(x);\n};\n/**\n @param {*} x\n @return {boolean}\n */\n$jscomp.number.isSafeInteger = function(x) {\n  return $jscomp.number.isInteger(x) && Math.abs(x) <= $jscomp.number.MAX_SAFE_INTEGER;\n};\n/** @const @type {number} */ $jscomp.number.EPSILON = Math.pow(2, -52);\n/** @const @type {number} */ $jscomp.number.MAX_SAFE_INTEGER = 9007199254740991;\n/** @const @type {number} */ $jscomp.number.MIN_SAFE_INTEGER = -9007199254740991;\n$jscomp.object = $jscomp.object || {};\n/**\n @param {!Object} target\n @param {...?Object} sources\n @return {!Object}\n */\n$jscomp.object.assign = function(target, sources) {\n  var $jscomp$restParams = [];\n  for (var $jscomp$restIndex = 1;$jscomp$restIndex < arguments.length;++$jscomp$restIndex) {\n    $jscomp$restParams[$jscomp$restIndex - 1] = arguments[$jscomp$restIndex];\n  }\n  var /** @type {!Array<?Object>} */ sources$15 = $jscomp$restParams;\n  for (var $jscomp$iter$7 = $jscomp.makeIterator(sources$15), $jscomp$key$source = $jscomp$iter$7.next();!$jscomp$key$source.done;$jscomp$key$source = $jscomp$iter$7.next()) {\n    /** @const */ var source = $jscomp$key$source.value;\n    if (!source) {\n      continue;\n    }\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\n/**\n @param {*} left\n @param {*} right\n @return {boolean}\n */\n$jscomp.object.is = function(left, right) {\n  if (left === right) {\n    return left !== 0 || 1 / left === 1 / /** @type {number} */ (right);\n  } else {\n    return left !== left && right !== right;\n  }\n};\n/**\n @struct\n @constructor\n @implements {Iterable<VALUE>}\n @param {(!Iterable<VALUE>|!Array<VALUE>)=} opt_iterable\n @template VALUE\n */\n$jscomp.Set = function(opt_iterable) {\n  opt_iterable = opt_iterable === undefined ? [] : opt_iterable;\n  /** @private @const @type {!$jscomp.Map<VALUE,VALUE>} */ this.map_ = new $jscomp.Map;\n  if (opt_iterable) {\n    for (var $jscomp$iter$8 = $jscomp.makeIterator(opt_iterable), $jscomp$key$item = $jscomp$iter$8.next();!$jscomp$key$item.done;$jscomp$key$item = $jscomp$iter$8.next()) {\n      /** @const */ var item = $jscomp$key$item.value;\n      this.add(/** @type {VALUE} */ (item));\n    }\n  }\n  this.size = this.map_.size;\n};\n/**\n @private\n @return {boolean}\n */\n$jscomp.Set.checkBrowserConformance_ = function() {\n  /** @const */ var Set = $jscomp.global[\"Set\"];\n  if (!Set || !Set.prototype.entries || !Object.seal) {\n    return false;\n  }\n  /** @const */ var value = Object.seal({x:4});\n  /** @const */ var set = new Set($jscomp.makeIterator([value]));\n  if (set.has(value) || set.size != 1 || set.add(value) != set || set.size != 1 || set.add({x:4}) != set || set.size != 2) {\n    return false;\n  }\n  /** @const */ var iter = set.entries();\n  var item = iter.next();\n  if (item.done || item.value[0] != value || item.value[1] != value) {\n    return false;\n  }\n  item = iter.next();\n  if (item.done || item.value[0] == value || item.value[0].x != 4 || item.value[1] != item.value[0]) {\n    return false;\n  }\n  return iter.next().done;\n};\n/**\n @param {VALUE} value\n */\n$jscomp.Set.prototype.add = function(value) {\n  this.map_.set(value, value);\n  this.size = this.map_.size;\n  return this;\n};\n/**\n @param {VALUE} value\n @return {boolean}\n */\n$jscomp.Set.prototype.delete = function(value) {\n  /** @const */ var result = this.map_.delete(value);\n  this.size = this.map_.size;\n  return result;\n};\n$jscomp.Set.prototype.clear = function() {\n  this.map_.clear();\n  this.size = 0;\n};\n/**\n @param {*} value\n @return {boolean}\n */\n$jscomp.Set.prototype.has = function(value) {\n  return this.map_.has(value);\n};\n/**\n @return {!IteratorIterable<!Array<VALUE>>}\n */\n$jscomp.Set.prototype.entries = function() {\n  return this.map_.entries();\n};\n/**\n @return {!IteratorIterable<VALUE>}\n */\n$jscomp.Set.prototype.values = function() {\n  return this.map_.values();\n};\n/**\n @param {function(this:THIS,VALUE,VALUE,!$jscomp.Set<VALUE>)} callback\n @param {THIS=} opt_thisArg\n @template THIS\n */\n$jscomp.Set.prototype.forEach = function(callback, opt_thisArg) {\n  /** @const */ var $jscomp$this = this;\n  this.map_.forEach(function(value) {\n    return callback.call(opt_thisArg, value, value, $jscomp$this);\n  });\n};\n/** @define {boolean} */ $jscomp.Set.ASSUME_NO_NATIVE = false;\n$jscomp.Set$install = function() {\n  if (!$jscomp.Set.ASSUME_NO_NATIVE && $jscomp.Set.checkBrowserConformance_()) {\n    $jscomp.Set = $jscomp.global[\"Set\"];\n  } else {\n    $jscomp.Map$install();\n    $jscomp.initSymbol();\n    $jscomp.initSymbolIterator();\n    $jscomp.Set.prototype[Symbol.iterator] = $jscomp.Set.prototype.values;\n  }\n  $jscomp.Set$install = function() {\n  };\n};\n$jscomp.string = $jscomp.string || {};\n/**\n @private\n @param {*} str\n @param {string} func\n */\n$jscomp.string.noNullOrUndefined_ = function(str, func) {\n  if (str == null) {\n    throw new TypeError(\"The 'this' value for String.prototype.\" + func + \" \" + \"must not be null or undefined\");\n  }\n};\n/**\n @private\n @param {*} str\n @param {string} func\n */\n$jscomp.string.noRegExp_ = function(str, func) {\n  if (str instanceof RegExp) {\n    throw new TypeError(\"First argument to String.prototype.\" + func + \" \" + \"must not be a regular expression\");\n  }\n};\n/**\n @param {...number} codepoints\n @return {string}\n */\n$jscomp.string.fromCodePoint = function(codepoints) {\n  var $jscomp$restParams = [];\n  for (var $jscomp$restIndex = 0;$jscomp$restIndex < arguments.length;++$jscomp$restIndex) {\n    $jscomp$restParams[$jscomp$restIndex - 0] = arguments[$jscomp$restIndex];\n  }\n  var /** @type {!Array<number>} */ codepoints$16 = $jscomp$restParams;\n  var result = \"\";\n  for (var $jscomp$iter$9 = $jscomp.makeIterator(codepoints$16), $jscomp$key$code = $jscomp$iter$9.next();!$jscomp$key$code.done;$jscomp$key$code = $jscomp$iter$9.next()) {\n    var code = $jscomp$key$code.value;\n    code = +code;\n    if (code < 0 || code > 1114111 || code !== Math.floor(code)) {\n      throw new RangeError(\"invalid_code_point \" + code);\n    }\n    if (code <= 65535) {\n      result += String.fromCharCode(code);\n    } else {\n      code -= 65536;\n      result += String.fromCharCode(code >>> 10 & 1023 | 55296);\n      result += String.fromCharCode(code & 1023 | 56320);\n    }\n  }\n  return result;\n};\n/**\n @this {*}\n @param {number} copies\n @return {string}\n */\n$jscomp.string.repeat = function(copies) {\n  $jscomp.string.noNullOrUndefined_(this, \"repeat\");\n  var /** string */ string = String(this);\n  if (copies < 0 || copies > 1342177279) {\n    throw new RangeError(\"Invalid count value\");\n  }\n  copies = copies | 0;\n  var result = \"\";\n  while (copies) {\n    if (copies & 1) {\n      result += string;\n    }\n    if (copies >>>= 1) {\n      string += string;\n    }\n  }\n  return result;\n};\n/**\n @const\n @suppress {checkTypes,const}\n */\n$jscomp.string.repeat$install = function() {\n  if (!String.prototype.repeat) {\n    String.prototype.repeat = $jscomp.string.repeat;\n  }\n};\n/**\n @this {*}\n @param {number} position\n @return {(number|undefined)}\n */\n$jscomp.string.codePointAt = function(position) {\n  $jscomp.string.noNullOrUndefined_(this, \"codePointAt\");\n  /** @const */ var string = String(this);\n  /** @const */ var size = string.length;\n  position = Number(position) || 0;\n  if (!(position >= 0 && position < size)) {\n    return void 0;\n  }\n  position = position | 0;\n  /** @const */ var first = string.charCodeAt(position);\n  if (first < 55296 || first > 56319 || position + 1 === size) {\n    return first;\n  }\n  /** @const */ var second = string.charCodeAt(position + 1);\n  if (second < 56320 || second > 57343) {\n    return first;\n  }\n  return (first - 55296) * 1024 + second + 9216;\n};\n/**\n @suppress {checkTypes,const}\n */\n$jscomp.string.codePointAt$install = function() {\n  if (!String.prototype.codePointAt) {\n    String.prototype.codePointAt = $jscomp.string.codePointAt;\n  }\n};\n/**\n @this {*}\n @param {string} searchString\n @param {number=} opt_position\n @return {boolean}\n */\n$jscomp.string.includes = function(searchString, opt_position) {\n  opt_position = opt_position === undefined ? 0 : opt_position;\n  $jscomp.string.noRegExp_(searchString, \"includes\");\n  $jscomp.string.noNullOrUndefined_(this, \"includes\");\n  /** @const */ var string = String(this);\n  return string.indexOf(searchString, opt_position) !== -1;\n};\n/**\n @suppress {checkTypes,const}\n */\n$jscomp.string.includes$install = function() {\n  if (!String.prototype.includes) {\n    String.prototype.includes = $jscomp.string.includes;\n  }\n};\n/**\n @this {*}\n @param {string} searchString\n @param {number=} opt_position\n @return {boolean}\n */\n$jscomp.string.startsWith = function(searchString, opt_position) {\n  opt_position = opt_position === undefined ? 0 : opt_position;\n  $jscomp.string.noRegExp_(searchString, \"startsWith\");\n  $jscomp.string.noNullOrUndefined_(this, \"startsWith\");\n  /** @const */ var string = String(this);\n  searchString = searchString + \"\";\n  /** @const */ var strLen = string.length;\n  /** @const */ var searchLen = searchString.length;\n  var i = Math.max(0, Math.min(opt_position | 0, string.length));\n  var j = 0;\n  while (j < searchLen && i < strLen) {\n    if (string[i++] != searchString[j++]) {\n      return false;\n    }\n  }\n  return j >= searchLen;\n};\n/**\n @suppress {checkTypes,const}\n */\n$jscomp.string.startsWith$install = function() {\n  if (!String.prototype.startsWith) {\n    String.prototype.startsWith = $jscomp.string.startsWith;\n  }\n};\n/**\n @this {*}\n @param {string} searchString\n @param {number=} opt_position\n @return {boolean}\n */\n$jscomp.string.endsWith = function(searchString, opt_position) {\n  $jscomp.string.noRegExp_(searchString, \"endsWith\");\n  $jscomp.string.noNullOrUndefined_(this, \"endsWith\");\n  /** @const */ var string = String(this);\n  searchString = searchString + \"\";\n  if (opt_position === void 0) {\n    opt_position = string.length;\n  }\n  var i = Math.max(0, Math.min(opt_position | 0, string.length));\n  var j = searchString.length;\n  while (j > 0 && i > 0) {\n    if (string[--i] != searchString[--j]) {\n      return false;\n    }\n  }\n  return j <= 0;\n};\n/**\n @suppress {checkTypes,const}\n */\n$jscomp.string.endsWith$install = function() {\n  if (!String.prototype.endsWith) {\n    String.prototype.endsWith = $jscomp.string.endsWith;\n  }\n};\n\n\n","js/license.js":"/*\n * Copyright 2015 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n","js/runtime_type_check.js":"/*\n * Copyright 2010 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * @fileoverview Provides the boilerplate code for run-time type checking.\n *\n * @author moedinger@google.com (Andrew Moedinger)\n * @author nadaa@google.com (Nada Amin)\n */\n'require base';\n\n/** @const */\n$jscomp.typecheck = {};\n\n/**\n * A state variable to suspend checking, to avoid infinite calls\n * caused by calling checked code from the checking functions.\n *\n * @type {boolean}\n */\n$jscomp.typecheck.suspendChecking = false;\n\n\n/**\n * Log and possibly format the run-time type check warning. This\n * function is customized at compile-time.\n *\n * @param {string} warning the warning to log.\n * @param {*} expr the faulty expression.\n */\n$jscomp.typecheck.log = function(warning, expr) {};\n\n/**\n * Checks that the given expression matches one of the given checkers,\n * logging if not, and returning the expression regardless.\n *\n * @param {*} expr the expression to check.\n * @param {!Array.<!$jscomp.typecheck.Checker>} checkers the checkers to\n *     use in checking, one of these has to match for checking to succeed.\n * @return {*} the given expression back.\n */\n$jscomp.typecheck.checkType = function(expr, checkers) {\n  if ($jscomp.typecheck.suspendChecking) {\n    return expr;\n  }\n  $jscomp.typecheck.suspendChecking = true;\n\n  for (var i = 0; i < checkers.length; i++) {\n    var checker = checkers[i];\n    var ok = checker.check(expr);\n    if (ok) {\n      $jscomp.typecheck.suspendChecking = false;\n      return expr;\n    }\n  }\n\n  var warning = $jscomp.typecheck.prettify_(expr) + ' not in ' +\n      checkers.join(' ');\n\n  $jscomp.typecheck.log(warning, expr);\n\n  $jscomp.typecheck.suspendChecking = false;\n  return expr;\n};\n\n\n/**\n * Prettify the given expression for printing.\n *\n * @param {*} expr the expression.\n * @return {string} a string representation of the given expression.\n * @private\n */\n$jscomp.typecheck.prettify_ = function(expr) {\n  var className = $jscomp.typecheck.getClassName_(expr);\n  if (className) {\n    return className;\n  }\n  try {\n    return String(expr);\n  }\n  catch (e) {}\n  return '<unknown>';\n};\n\n/**\n * Gets the class name if the given expression is an object.\n *\n * @param {*} expr the expression.\n * @return {string|undefined} the class name or undefined if the\n *     expression is not an object.\n * @private\n */\n$jscomp.typecheck.getClassName_ = function(expr) {\n  var className = void 0;\n  if (typeof expr == 'object' && expr && expr.constructor) {\n    className = expr.constructor.name;\n    if (!className) {\n      var funNameRe = /function (.{1,})\\(/;\n      var m = (funNameRe).exec(expr.constructor.toString());\n      className = m && m.length > 1 ? m[1] : void 0;\n    }\n  }\n  return className;\n};\n\n/**\n * Interface for all checkers.\n *\n * @interface\n */\n$jscomp.typecheck.Checker = function() {};\n\n\n/**\n * Checks the given expression.\n *\n * @param {*} expr the expression to check.\n * @return {boolean} whether the given expression matches this checker.\n */\n$jscomp.typecheck.Checker.prototype.check = function(expr) {};\n\n\n\n/**\n * A class for all value checkers, except the null checker.\n *\n * @param {string} type the value type (e.g. 'number') of this checker.\n * @constructor\n * @implements {$jscomp.typecheck.Checker}\n * @private\n */\n$jscomp.typecheck.ValueChecker_ = function(type) {\n  /**\n   * The value type of this checker.\n   * @type {string}\n   * @private\n   */\n  this.type_ = type;\n};\n\n\n/** @inheritDoc */\n$jscomp.typecheck.ValueChecker_.prototype.check = function(expr) {\n  return typeof(expr) == this.type_;\n};\n\n\n/** @inheritDoc */\n$jscomp.typecheck.ValueChecker_.prototype.toString = function() {\n  return 'value(' + this.type_ + ')';\n};\n\n\n\n/**\n * A checker class for null values.\n *\n * @constructor\n * @implements {$jscomp.typecheck.Checker}\n * @private\n */\n$jscomp.typecheck.NullChecker_ = function() {};\n\n\n/** @inheritDoc */\n$jscomp.typecheck.NullChecker_.prototype.check = function(expr) {\n  return expr === null;\n};\n\n\n/** @inheritDoc */\n$jscomp.typecheck.NullChecker_.prototype.toString = function() {\n  return 'value(null)';\n};\n\n\n/**\n * A checker class for a class defined in externs, including built-in\n * JS types.\n *\n * <p>If the class type is undefined, then checking is suspended to\n * avoid spurious warnings. This is necessary because some externs\n * types are not defined in all browsers. For example, Window is not\n * defined Chrome, as window has the type DOMWindow.\n *\n * <p>Another subtlety is that a built-in type may be referenced in a\n * different frame than the one in which it was created. This causes\n * instanceOf to return false even though the object is of the correct\n * type. We work around this by checking as many windows as possible,\n * redefining open on top and window to keep track of them.\n *\n * @param {string} className the name of the extern class to check.\n * @constructor\n * @implements {$jscomp.typecheck.Checker}\n * @private\n */\n$jscomp.typecheck.ExternClassChecker_ = function(className) {\n  /**\n   * The name of the extern class to check.\n   * @type {string}\n   * @private\n   */\n  this.className_ = className;\n};\n\n\n/**\n * A list of (hopefully all) open windows.\n *\n * @type {!Array.<!Window>}\n */\n$jscomp.typecheck.ExternClassChecker_.windows = [];\n\n\n/**\n * A list of the original open methods that have been redefined.\n *\n * @type {!Array.<!Function>}\n */\n$jscomp.typecheck.ExternClassChecker_.oldOpenFuns = [];\n\n\n/**\n * Redefines the open method on the given window, adding tracking.\n *\n * @param {!Window} win the window to track.\n */\n$jscomp.typecheck.ExternClassChecker_.trackOpenOnWindow = function(win) {\n  if (win.tracked) {\n    return;\n  }\n  win.tracked = true;\n\n  var key = $jscomp.typecheck.ExternClassChecker_.oldOpenFuns.length;\n\n  $jscomp.typecheck.ExternClassChecker_.oldOpenFuns.push(win.open);\n  $jscomp.typecheck.ExternClassChecker_.windows.push(win);\n\n  win.open = function() {\n    var w = $jscomp.typecheck.ExternClassChecker_.oldOpenFuns[key].apply(\n        this, arguments);\n    $jscomp.typecheck.ExternClassChecker_.trackOpenOnWindow(w);\n    return w;\n  };\n};\n\n\n/**\n * Returns the global 'this' object. This will normally be the same as 'window'\n * but when running in a worker thread, the DOM is not available.\n * @return {!Window}\n * @private\n */\n$jscomp.typecheck.ExternClassChecker_.getGlobalThis_ = function() {\n  return (function() { return this; }).call(null);\n};\n\n\n// Install listeners on the global 'this' object.\n(function() {\n  var globalThis = $jscomp.typecheck.ExternClassChecker_.getGlobalThis_();\n  $jscomp.typecheck.ExternClassChecker_.trackOpenOnWindow(globalThis);\n\n  var theTop = globalThis['top'];\n  if (theTop) {\n    $jscomp.typecheck.ExternClassChecker_.trackOpenOnWindow(theTop);\n  }\n})();\n\n\n/** @inheritDoc */\n$jscomp.typecheck.ExternClassChecker_.prototype.check = function(expr) {\n  var classTypeDefined = [ false ];\n  for (var i = 0; i < $jscomp.typecheck.ExternClassChecker_.windows.length;\n      i++) {\n    var w = $jscomp.typecheck.ExternClassChecker_.windows[i];\n    if (this.checkWindow_(w, expr, classTypeDefined)) {\n      return true;\n    }\n  }\n  return !classTypeDefined[0];\n};\n\n\n/** @inheritDoc */\n$jscomp.typecheck.ExternClassChecker_.prototype.toString = function() {\n  return 'ext_class(' + this.className_ + ')';\n};\n\n\n/**\n * Checks whether the given expression is an instance of this extern\n * class in this window or any of its frames and subframes.\n *\n * @param {!Window} w the window to start checking from.\n * @param {*} expr the expression to check.\n * @param {!Array.<boolean>} classTypeDefined a wrapped boolean\n *     updated to indicate whether the class type was seen in any frame.\n * @return true if the given expression is an instance of this class.\n * @private\n */\n$jscomp.typecheck.ExternClassChecker_.prototype.checkWindow_ =\n    function(w, expr, classTypeDefined) {\n  var classType = w[this.className_];\n  classTypeDefined[0] |= !!classType;\n  if (classType && expr instanceof classType) {\n    return true;\n  }\n  for (var i = 0; i < w.length; i++) {\n    if (this.checkWindow_(w.frames[i], expr, classTypeDefined)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n\n\n/**\n * A class for all checkers of user-defined classes.\n *\n * @param {string} className name of the class to check.\n * @constructor\n * @implements {$jscomp.typecheck.Checker}\n * @private\n */\n$jscomp.typecheck.ClassChecker_ = function(className) {\n\n  /**\n   * The name of the class to check.\n   * @type {string}\n   * @private\n   */\n  this.className_ = className;\n};\n\n\n/** @inheritDoc */\n$jscomp.typecheck.ClassChecker_.prototype.check = function(expr) {\n  return !!(expr && expr['instance_of__' + this.className_]);\n};\n\n\n/** @inheritDoc */\n$jscomp.typecheck.ClassChecker_.prototype.toString = function() {\n  return 'class(' + this.className_ + ')';\n};\n\n\n\n/**\n * A class for all checkers of user-defined interfaces.\n *\n * @param {string} interfaceName name of the interface to check.\n * @constructor\n * @implements {$jscomp.typecheck.Checker}\n * @private\n */\n$jscomp.typecheck.InterfaceChecker_ = function(interfaceName) {\n\n  /**\n   * The name of the interface to check.\n   * @type {string}\n   * @private\n   */\n  this.interfaceName_ = interfaceName;\n};\n\n\n/** @inheritDoc */\n$jscomp.typecheck.InterfaceChecker_.prototype.check = function(expr) {\n  return !!(expr && expr['implements__' + this.interfaceName_]);\n};\n\n\n/** @inheritDoc */\n$jscomp.typecheck.InterfaceChecker_.prototype.toString = function() {\n  return 'interface(' + this.interfaceName_ + ')';\n};\n\n\n\n/**\n * A checker for object types (possibly with non-standard prototype: might not\n * inherit from Object).\n *\n * @constructor\n * @implements {$jscomp.typecheck.Checker}\n * @private\n */\n$jscomp.typecheck.ObjectChecker_ = function() {};\n\n\n/** @inheritDoc */\n$jscomp.typecheck.ObjectChecker_.prototype.check = function(expr) {\n  return typeof(expr) == 'object' && !!expr;\n};\n\n\n/** @inheritDoc */\n$jscomp.typecheck.ObjectChecker_.prototype.toString = function() {\n  return 'value(object)';\n};\n\n\n\n/**\n * A checker for null values.\n *\n * @type {!$jscomp.typecheck.Checker} a checker.\n */\n$jscomp.typecheck.nullChecker = new $jscomp.typecheck.NullChecker_();\n\n\n/**\n * Creates a checker for the given value type (excluding the null type).\n *\n * @param {string} type the value type.\n * @return {!$jscomp.typecheck.Checker} a checker.\n */\n$jscomp.typecheck.valueChecker = function(type) {\n  return new $jscomp.typecheck.ValueChecker_(type);\n};\n\n\n/**\n * Creates a checker for the given extern class name.\n *\n * @param {string} className the class name.\n * @return {!$jscomp.typecheck.Checker} a checker.\n */\n$jscomp.typecheck.externClassChecker = function(className) {\n  return new $jscomp.typecheck.ExternClassChecker_(className);\n};\n\n\n/**\n * Creates a checker for the given user-defined class.\n *\n * @param {string} className the class name.\n * @return {!$jscomp.typecheck.Checker} a checker.\n */\n$jscomp.typecheck.classChecker = function(className) {\n  return new $jscomp.typecheck.ClassChecker_(className);\n};\n\n\n/**\n * Creates a checker for the given user-defined interface.\n *\n * @param {string} interfaceName the interface name.\n * @return {!$jscomp.typecheck.Checker} a checker.\n */\n$jscomp.typecheck.interfaceChecker = function(interfaceName) {\n  return new $jscomp.typecheck.InterfaceChecker_(interfaceName);\n};\n\n\n/**\n * A checker for objects.\n *\n * @type {!$jscomp.typecheck.Checker} a checker.\n */\n$jscomp.typecheck.objectChecker = new $jscomp.typecheck.ObjectChecker_();\n"}
