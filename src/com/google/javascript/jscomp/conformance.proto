// Copyright 2014 The Closure Compiler Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto2";

package jscomp;

option java_package = "com.google.javascript.jscomp";
option java_multiple_files = true;

// A container to describe code requirements
message ConformanceConfig {
  repeated Requirement requirement = 1;
}

// A specification of code requirements
// NEXT ID: 15
message Requirement {
  // Required: The message to report when a requirement is violated. This should
  // reference a document describing the reasoning for the requirement
  // and contacts.
  optional string error_message = 1;

  // Optional: A list of source path prefixes that are exempt from the
  // requirement.
  repeated string whitelist = 2;

  // Optional: A list of source paths regexs that are exempt from the
  // requirement.
  repeated string whitelist_regexp = 3;

  message WhitelistEntry {
    enum Reason {
      UNSPECIFIED = 0;
      LEGACY = 1;
      OUT_OF_SCOPE = 2;
      MANUALLY_REVIEWED = 3;
    }

    optional Reason reason = 1;

    // A list of source path prefixes.
    repeated string prefix = 2;

    // A list of regexes matching sources to be ignored
    repeated string regexp = 3;

    // Short explanation.
    optional string explanation = 4;

    repeated string comment = 5;
  }

  repeated WhitelistEntry whitelist_entry = 14;

  // Optional: A list of source paths that will be checked for the requirement
  // (the opposite of whitelist).
  repeated string only_apply_to = 4;

  // Optional: A list of source path regexps that will be checked for
  // the requirement (the opposite of whitelist_regexp).
  repeated string only_apply_to_regexp = 5;

  // A classification of the requirement and how it is enforced.
  enum Type {
    // A requirement enforced with code a external java class.
    CUSTOM = 1;

    // A forbidden source file
    BANNED_DEPENDENCY = 2;

    // A forbidden fully distinguished name. For example:
    //  - A global name like "eval" or "goog"
    //  - A namespaced value or type:  namespace.Banned
    //  - A 'static' property:  "namespace.Foo.banned"
    // TODO(b/112325992): If namespace.Banned is a goog.module that does not
    // call goog.module.declareNamespace, the rule will not match.
    BANNED_NAME = 3;

    // A banned instance property, for example:
    //  - An 'instance' property:   "namespace.Foo.prototype.banned"
    //  - All properties of a given name "Object.prototype.banned"
    BANNED_PROPERTY = 4;

    // A banned reading from an instance property, for example:
    //  - An 'instance' property:   "namespace.Foo.prototype.banned"
    //  - All properties of a given name "Object.prototype.banned"
    // Unlike BANNED_PROPERTY, this only bans reads to the property,
    // i.e. its use as an rvalue.
    BANNED_PROPERTY_READ = 5;

    // A banned write to an instance property, for example:
    //  - An 'instance' property:   "namespace.Foo.prototype.banned"
    //  - All properties of a given name "Object.prototype.banned"
    // Unlike BANNED_PROPERTY, this only bans assignments to the property,
    // i.e. its use as an lvalue.
    BANNED_PROPERTY_WRITE = 6;

    // A restricted call, for example:
    //  - the "parseInt" call must be called with a radix:
    //  parseInt:function(string, int)
    RESTRICTED_NAME_CALL = 7;

    // A restricted call, for example:
    //  - The unsafe opt_html parameter must not be passed to createNode:
    //  goog.ui.tree.TreeControl.prototype.createNode:function()
    RESTRICTED_METHOD_CALL = 8;

    // A banned code pattern. This check is done using against an AST.
    // To ban a call to eval:
    //    "/** @param {?} a */ function template(a) {eval(a);}"
    BANNED_CODE_PATTERN = 9;

    // A banned function call. for example:
    //  - An 'instance' property: "namespace.Foo.prototype.banned"
    //  - All properties of a given name "Object.prototype.banned"
    // Unlike BANNED_PROPERTY, this only bans calls to the property
    // i.e. using the property as a value is allowed.
    BANNED_PROPERTY_CALL = 10;

    // A banned write of a non-constant value to an instance property.
    // Unlike BANNED_PROPERTY_WRITE, this only bans assignments of a
    // non-constant value.
    BANNED_PROPERTY_NON_CONSTANT_WRITE = 11;

    // A banned function call.
    // Unlike BANNED_NAME, this only bans calls to the property, i.e. using the
    // property as a value is allowed.
    BANNED_NAME_CALL = 12;

    // A restricted write to an instance property.
    // Example: "Element.prototype.innerHTML:!TrustedHTML|string"
    RESTRICTED_PROPERTY_WRITE = 13;
  }

  enum TypeMatchingStrategy {
    UNKNOWN = 0;

    // Matches type or any subtype. Matches types with different
    // nullability/voidability. Allows loose matches.
    LOOSE = 1;

    // Matches type or any subtype. Does not match types with different
    // nullability/voidability. Allows loose matches.
    STRICT_NULLABILITY = 2;

    // Matches type or any subtype. Does not match types with different
    // nullability/voidability. Does not allow loose matches.
    SUBTYPES = 3;

    // Does not match subtypes. Does not match types with different
    // nullability/voidability. Does not allow loose matches.
    EXACT = 4;
  }

  // Required: The type of requirement.
  optional Type type = 6;

  // The value banned, optional for "custom" requirements.
  repeated string value = 7;

  // Strategy to use for matching types in the value parameter (e.g. for
  // BANNED_CODE_PATTERN checks).
  optional TypeMatchingStrategy type_matching_strategy = 13 [default = LOOSE];

  // For "custom" requirements, the Java class used to enforce the requirement.
  // Ignored otherwise.
  optional string java_class = 8;

  // Gives the rule an unique ID that can be used for extending in other rules
  // through 'extends'. An example of ID is 'closure:innerHtml'.
  optional string rule_id = 9;

  // Allows extending whitelists of rules with the specified rule_id. If this
  // field is specified then all fields except whitelist, whitelist_regexp,
  // only_apply_to and only_apply_to_regexp are ignored.
  optional string extends = 10;

  // Whether to report possible violations when type information is not exact.
  // Normally, violations on parent types are reported as possible violations.
  // This field allows to ignore them and report only violations on exact types.
  // This changes the balance between the false positives and the false
  // negatives. With the default value, there might be lots of false positives
  // (possible violations) but there shouldn't be any false negatives. Without
  // reporting the loose type violations, there will be less false positives but
  // there can also be false negatives (an actual violation that is not
  // reported).
  optional bool report_loose_type_violations = 11 [default = true];

  // With what severity to report the issue by default.
  enum Severity {
    // Currently treated the same as WARNING.
    UNSPECIFIED = 0;
    // Allows the build to continue. Can be turned into an error by setting the
    // jscomp_error=conformanceConfig flag.
    WARNING = 1;
    // The build fails if we are confident this is an error.
    // This causes an error even on possible violations, e.g. when the type
    // system is ambiguous.
    ERROR = 2;
  }

  optional Severity severity = 12 [default = WARNING];

  // CUSTOM requirements may use extensions, each extension should use
  // a CL number as a unique identifier.
  extensions 1000000 to max;
}
